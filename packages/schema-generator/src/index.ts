import { writeFile } from "node:fs/promises";
import { basename, join } from "node:path";
import type { JSONSchema } from "json-schema-to-typescript/dist/src/types/JSONSchema";
import { type StructuredSchema, StructuredSchemaGenerator } from "./StructuredSchemaGenerator";
import { ensureDirectoryHasCleaned, listFiles, readJSONSchema, throwIfInvalidSrc } from "./util";

const SCHEMA_DIR = join(import.meta.dirname, "../../../vrm-specification/specification");
const PACKAGES_DIR = join(import.meta.dirname, "../../../packages");

const paths = [
    // VRM 0.0
    {
        src: join(SCHEMA_DIR, "/0.0/schema"),
        dest: join(PACKAGES_DIR, "/VRM_0.0/src/schema"),
    },
    // VRMC_materials_hdr_emissiveMultiplier-1.0
    {
        src: join(SCHEMA_DIR, "/VRMC_materials_hdr_emissiveMultiplier-1.0/schema"),
        dest: join(PACKAGES_DIR, "/VRMC_materials_hdr_emissiveMultiplier-1.0/src/schema"),
    },
    // VRMC_materials_mtoon-1.0
    {
        src: join(SCHEMA_DIR, "/VRMC_materials_mtoon-1.0/schema"),
        dest: join(PACKAGES_DIR, "/VRMC_materials_mtoon-1.0/src/schema"),
    },
    // VRMC_node_constraint-1.0
    {
        src: join(SCHEMA_DIR, "/VRMC_node_constraint-1.0/schema"),
        dest: join(PACKAGES_DIR, "/VRMC_node_constraint-1.0/src/schema"),
    },
    // VRMC_springBone_extended_collider-1.0
    {
        src: join(SCHEMA_DIR, "/VRMC_springBone_extended_collider-1.0/schema"),
        dest: join(PACKAGES_DIR, "/VRMC_springBone_extended_collider-1.0/src/schema"),
    },
    // VRMC_springBone-1.0
    {
        src: join(SCHEMA_DIR, "/VRMC_springBone-1.0/schema"),
        dest: join(PACKAGES_DIR, "/VRMC_springBone-1.0/src/schema"),
    },
    // VRMC_vrm_animation-1.0
    {
        src: join(SCHEMA_DIR, "/VRMC_vrm_animation-1.0/schema"),
        dest: join(PACKAGES_DIR, "/VRMC_vrm_animation-1.0/src/schema"),
    },
    // VRMC_vrm-1.0
    {
        src: join(SCHEMA_DIR, "/VRMC_vrm-1.0/schema"),
        dest: join(PACKAGES_DIR, "/VRMC_vrm-1.0/src/schema"),
    },
];

function convertJSONSchemaToTypeScriptInterface(jsonSchema: JSONSchema): string {
    const structuredSchema = new StructuredSchemaGenerator().generate(jsonSchema);

    if (!structuredSchema.title) {
        throw new Error("Schema title is missing or invalid.");
    }

    if (structuredSchema.ref) {
        structuredSchema.ref = formatInterfaceName(structuredSchema.ref);
    }

    const lines: string[] = [];
    lines.push(
        `export interface ${formatInterfaceName(structuredSchema.title)}${structuredSchema.ref ? ` extends ${structuredSchema.ref}` : ""} {`,
    );

    if (structuredSchema.properties) {
        for (const [propName, propSchema] of Object.entries(structuredSchema.properties)) {
            if (propName === "extensions" || propName === "extras") {
                // Skip extensions and extras as they are already defined in IGLTFProperty
                continue;
            }
            const isRequired = structuredSchema.required?.includes(propName) ?? false;
            const comments: string[] = [];
            if (propSchema.metadata) {
                for (const key of Object.keys(propSchema.metadata)) {
                    comments.push(`* @${key} ${JSON.stringify(propSchema.metadata[key])}`);
                }
            }
            lines.push("");
            if (comments.length > 0) {
                lines.push("    /**");
                lines.push(...comments.map((c) => `    ${c}`));
                lines.push("    */");
            }
            const typeStr = resolveType(propSchema, propName);
            lines.push(`    ${propName}${isRequired ? "" : "?"}: ${typeStr};`);
        }
    }
    lines.push("}");
    lines.push("");

    return `import type { IGLTFProperty, IGLTFChildOfRootProperty, IGLTFId, ITextureInfo } from "@yamayuski/babylon-vrm-core";

/**
 * THIS SCHEMA TYPE DEFINITION FILE IS AUTO-GENERATED.
 * DO NOT EDIT THIS FILE DIRECTLY.
 * Instead, edit the JSON schema and run the script to regenerate.
 *
 * Source JSON Schema: "${jsonSchema.title}"
 */
${lines.join("\n")}
`;
}

function formatInterfaceName(title: string): string {
    switch (title) {
        case "glTFProperty.schema.json": {
            return "IGLTFProperty";
        }
        case "glTFChildOfRootProperty.schema.json": {
            return "IGLTFChildOfRootProperty";
        }
        case "glTFid.schema.json": {
            return "IGLTFId";
        }
        case "textureInfo.schema.json": {
            return "ITextureInfo";
        }
        default: {
            title = title.replace(".schema.json", "").replace(".json", "");
            break;
        }
    }
    // Remove invalid characters except dot and underscore (used as delimiters)
    const cleaned = title
        .replace(/[^a-zA-Z0-9._]/g, "")
        .replace(".schema.json", "")
        .replace(".json", "");

    // Split on delimiters '.' and '_' and capitalize each segment's first letter
    const segments = cleaned.split(/[._]+/).filter(Boolean);
    if (segments.length === 0) {
        throw new Error("Schema title is missing or invalid after cleaning.");
    }

    const combined = segments
        .map((seg) => {
            if (seg.length === 0) return "";
            // For first segment, preserve original casing except ensure first char is uppercase
            const first = seg.charAt(0).toUpperCase();
            const rest = seg.slice(1);
            return `${first}${rest}`;
        })
        .join("");

    return `I${combined}`;
}

function resolveType(schema: StructuredSchema, propName: string): string {
    if (schema.ref) {
        return formatInterfaceName(schema.ref);
    }
    if (schema.metadata?.enum) {
        return (schema.metadata.enum as string[]).map((v) => JSON.stringify(v)).join(" | ");
    }
    switch (schema.type) {
        case "string":
        case "boolean":
        case "number":
        case "null":
            return schema.type;
        case "integer":
            return "number"; // TypeScript does not have a separate integer type
        case "array":
            if (schema.items) {
                if (Array.isArray(schema.items)) {
                    const itemTypes = schema.items.map((it) => resolveType(it, propName));
                    return `(${itemTypes.join(", ")})[]`;
                }
                const itemType = resolveType(schema.items, propName);
                return `${itemType}[]`;
            }
            return "unknown[]";
        case "object":
            if (schema.properties && propName in schema.properties) {
                return resolveType(schema.properties[propName], propName);
            }
            if (schema.additionalProperties) {
                if (schema.additionalProperties === true) {
                    return "Record<string, unknown>";
                }
                return `Record<string, ${resolveType(schema.additionalProperties, propName)}>`;
            }
            if (schema.properties) {
                return `{ ${Object.entries(schema.properties)
                    .map(([key, val]) => {
                        const isRequired = schema.required?.includes(key) ?? false;
                        return `${key}${isRequired ? "" : "?"}: ${resolveType(val, key)}`;
                    })
                    .join("; ")} }`;
            }
            console.warn(
                `Warning: Property "${propName}" is of type object but has no defined properties. Using "Record<string, unknown>".`,
            );
            return "Record<string, unknown>";
        default:
            console.warn(
                `Warning: Property "${propName}" has unknown or unsupported type "${schema.type}". Using "unknown".`,
            );
            return "unknown";
    }
}

async function generateSchema(srcDir: string, destDir: string) {
    await throwIfInvalidSrc(srcDir);
    await ensureDirectoryHasCleaned(destDir);

    const promises: Promise<void>[] = [];
    for await (const file of listFiles(srcDir)) {
        promises.push(
            readJSONSchema(file)
                .then(convertJSONSchemaToTypeScriptInterface)
                .then((ts) => {
                    const outPath = join(destDir, `${basename(file, ".json")}.d.ts`);
                    return writeFile(outPath, ts, "utf-8");
                }),
        );
    }
    await Promise.all(promises);
}

/**
 * Main function to generate schemas for all specified paths.
 * @returns Promise that resolves when all schema generation tasks are complete
 */
async function main() {
    const promises: Promise<void>[] = [];
    for (const path of paths) {
        promises.push(generateSchema(path.src, path.dest));
    }
    return Promise.all(promises);
}

// entrypoint
main()
    .then(() => {
        console.log("Schema generation completed.");
        process.exit(0);
    })
    .catch((err) => {
        console.error(err);
        process.exit(1);
    });
