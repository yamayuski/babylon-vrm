/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * VRM extension is for 3d humanoid avatars (and models) in VR applications.
 */
export interface Vrm {
    /**
     * Version of exporter that vrm created. UniVRM-0.46
     */
    exporterVersion?: string;
    /**
     * Version of VRM specification. 0.0
     */
    specVersion?: string;
    meta?: VrmMeta;
    humanoid?: VrmHumanoid;
    firstPerson?: VrmFirstperson;
    blendShapeMaster?: VrmBlendshape;
    secondaryAnimation?: VrmSecondaryanimation;
    materialProperties?: VrmMaterial[];
}
export interface VrmMeta {
    /**
     * Title of VRM model
     */
    title?: string;
    /**
     * Version of VRM model
     */
    version?: string;
    /**
     * Author of VRM model
     */
    author?: string;
    /**
     * Contact Information of VRM model author
     */
    contactInformation?: string;
    /**
     * Reference of VRM model
     */
    reference?: string;
    /**
     * Thumbnail of VRM model
     */
    texture?: number;
    /**
     * A person who can perform with this avatar
     */
    allowedUserName?: "OnlyAuthor" | "ExplicitlyLicensedPerson" | "Everyone";
    /**
     * Permission to perform violent acts with this avatar
     */
    violentUssageName?: "Disallow" | "Allow";
    /**
     * Permission to perform sexual acts with this avatar
     */
    sexualUssageName?: "Disallow" | "Allow";
    /**
     * For commercial use
     */
    commercialUssageName?: "Disallow" | "Allow";
    /**
     * If there are any conditions not mentioned above, put the URL link of the license document here.
     */
    otherPermissionUrl?: string;
    /**
     * License type
     */
    licenseName?:
        | "Redistribution_Prohibited"
        | "CC0"
        | "CC_BY"
        | "CC_BY_NC"
        | "CC_BY_SA"
        | "CC_BY_NC_SA"
        | "CC_BY_ND"
        | "CC_BY_NC_ND"
        | "Other";
    /**
     * If “Other” is selected, put the URL link of the license document here.
     */
    otherLicenseUrl?: string;
}
export interface VrmHumanoid {
    humanBones?: VrmHumanoidBone[];
    /**
     * Unity's HumanDescription.armStretch
     */
    armStretch?: number;
    /**
     * Unity's HumanDescription.legStretch
     */
    legStretch?: number;
    /**
     * Unity's HumanDescription.upperArmTwist
     */
    upperArmTwist?: number;
    /**
     * Unity's HumanDescription.lowerArmTwist
     */
    lowerArmTwist?: number;
    /**
     * Unity's HumanDescription.upperLegTwist
     */
    upperLegTwist?: number;
    /**
     * Unity's HumanDescription.lowerLegTwist
     */
    lowerLegTwist?: number;
    /**
     * Unity's HumanDescription.feetSpacing
     */
    feetSpacing?: number;
    /**
     * Unity's HumanDescription.hasTranslationDoF
     */
    hasTranslationDoF?: boolean;
}
export interface VrmHumanoidBone {
    /**
     * Human bone name.
     */
    bone?:
        | "hips"
        | "leftUpperLeg"
        | "rightUpperLeg"
        | "leftLowerLeg"
        | "rightLowerLeg"
        | "leftFoot"
        | "rightFoot"
        | "spine"
        | "chest"
        | "neck"
        | "head"
        | "leftShoulder"
        | "rightShoulder"
        | "leftUpperArm"
        | "rightUpperArm"
        | "leftLowerArm"
        | "rightLowerArm"
        | "leftHand"
        | "rightHand"
        | "leftToes"
        | "rightToes"
        | "leftEye"
        | "rightEye"
        | "jaw"
        | "leftThumbProximal"
        | "leftThumbIntermediate"
        | "leftThumbDistal"
        | "leftIndexProximal"
        | "leftIndexIntermediate"
        | "leftIndexDistal"
        | "leftMiddleProximal"
        | "leftMiddleIntermediate"
        | "leftMiddleDistal"
        | "leftRingProximal"
        | "leftRingIntermediate"
        | "leftRingDistal"
        | "leftLittleProximal"
        | "leftLittleIntermediate"
        | "leftLittleDistal"
        | "rightThumbProximal"
        | "rightThumbIntermediate"
        | "rightThumbDistal"
        | "rightIndexProximal"
        | "rightIndexIntermediate"
        | "rightIndexDistal"
        | "rightMiddleProximal"
        | "rightMiddleIntermediate"
        | "rightMiddleDistal"
        | "rightRingProximal"
        | "rightRingIntermediate"
        | "rightRingDistal"
        | "rightLittleProximal"
        | "rightLittleIntermediate"
        | "rightLittleDistal"
        | "upperChest";
    /**
     * Reference node index
     */
    node?: number;
    /**
     * Unity's HumanLimit.useDefaultValues
     */
    useDefaultValues?: boolean;
    /**
     * Unity's HumanLimit.min
     */
    min?: {
        x?: number;
        y?: number;
        z?: number;
    };
    /**
     * Unity's HumanLimit.max
     */
    max?: {
        x?: number;
        y?: number;
        z?: number;
    };
    /**
     * Unity's HumanLimit.center
     */
    center?: {
        x?: number;
        y?: number;
        z?: number;
    };
    /**
     * Unity's HumanLimit.axisLength
     */
    axisLength?: number;
}
export interface VrmFirstperson {
    /**
     * The bone whose rendering should be turned off in first-person view. Usually Head is specified.
     */
    firstPersonBone?: number;
    /**
     * The target position of the VR headset in first-person view. It is assumed that an offset from the head bone to the VR headset is added.
     */
    firstPersonBoneOffset?: {
        x?: number;
        y?: number;
        z?: number;
    };
    /**
     * Switch display / undisplay for each mesh in first-person view or the others.
     */
    meshAnnotations?: VrmFirstpersonMeshannotation[];
    /**
     * Eye controller mode.
     */
    lookAtTypeName?: "Bone" | "BlendShape";
    lookAtHorizontalInner?: VrmFirstpersonDegreemap;
    lookAtHorizontalOuter?: VrmFirstpersonDegreemap;
    lookAtVerticalDown?: VrmFirstpersonDegreemap;
    lookAtVerticalUp?: VrmFirstpersonDegreemap;
}
export interface VrmFirstpersonMeshannotation {
    mesh?: number;
    firstPersonFlag?: string;
}
/**
 * Eye controller setting.
 */
export interface VrmFirstpersonDegreemap {
    /**
     * None linear mapping params. time, value, inTangent, outTangent
     */
    curve?: number[];
    /**
     * Look at input clamp range degree.
     */
    xRange?: number;
    /**
     * Look at map range degree from xRange.
     */
    yRange?: number;
}
/**
 * BlendShapeAvatar of UniVRM
 */
export interface VrmBlendshape {
    blendShapeGroups?: VrmBlendshapeGroup[];
}
export interface VrmBlendshapeGroup {
    /**
     * Expression name
     */
    name?: string;
    /**
     * Predefined Expression name
     */
    presetName?:
        | "unknown"
        | "neutral"
        | "a"
        | "i"
        | "u"
        | "e"
        | "o"
        | "blink"
        | "joy"
        | "angry"
        | "sorrow"
        | "fun"
        | "lookup"
        | "lookdown"
        | "lookleft"
        | "lookright"
        | "blink_l"
        | "blink_r";
    /**
     * Low level blendshape references.
     */
    binds?: VrmBlendshapeBind[];
    /**
     * Material animation references.
     */
    materialValues?: VrmBlendshapeMaterialbind[];
    /**
     * 0 or 1. Do not allow an intermediate value. Value should rounded
     */
    isBinary?: boolean;
}
export interface VrmBlendshapeBind {
    mesh?: number;
    index?: number;
    /**
     * SkinnedMeshRenderer.SetBlendShapeWeight
     */
    weight?: number;
}
export interface VrmBlendshapeMaterialbind {
    materialName?: string;
    propertyName?: string;
    targetValue?: number[];
}
/**
 * The setting of automatic animation of string-like objects such as tails and hairs.
 */
export interface VrmSecondaryanimation {
    boneGroups?: VrmSecondaryanimationSpring[];
    colliderGroups?: VrmSecondaryanimationCollidergroup[];
}
export interface VrmSecondaryanimationSpring {
    /**
     * Annotation comment
     */
    comment?: string;
    /**
     * The resilience of the swaying object (the power of returning to the initial pose).
     */
    stiffiness?: number;
    /**
     * The strength of gravity.
     */
    gravityPower?: number;
    /**
     * The direction of gravity. Set (0, -1, 0) for simulating the gravity. Set (1, 0, 0) for simulating the wind.
     */
    gravityDir?: {
        x?: number;
        y?: number;
        z?: number;
    };
    /**
     * The resistance (deceleration) of automatic animation.
     */
    dragForce?: number;
    /**
     * The reference point of a swaying object can be set at any location except the origin. When implementing UI moving with warp, the parent node to move with warp can be specified if you don't want to make the object swaying with warp movement.
     */
    center?: number;
    /**
     * The radius of the sphere used for the collision detection with colliders.
     */
    hitRadius?: number;
    /**
     * Specify the node index of the root bone of the swaying object.
     */
    bones?: number[];
    /**
     * Specify the index of the collider group for collisions with swaying objects.
     */
    colliderGroups?: number[];
}
export interface VrmSecondaryanimationCollidergroup {
    /**
     * The node of the collider group for setting up collision detections.
     */
    node?: number;
    colliders?: {
        /**
         * The local coordinate from the node of the collider group in *left-handed* Y-up coordinate.
         */
        offset?: {
            x?: number;
            y?: number;
            z?: number;
        };
        /**
         * The radius of the collider.
         */
        radius?: number;
    }[];
}
export interface VrmMaterial {
    name?: string;
    /**
     * This contains shader name.  VRM/MToon, VRM/UnlitTransparentZWrite, and VRM_USE_GLTFSHADER (and legacy materials as Standard, UniGLTF/UniUnlit, VRM/UnlitTexture, VRM/UnlitCutout, VRM/UnlitTransparent) . If VRM_USE_GLTFSHADER is specified, use same index of gltf's material settings
     */
    shader?: string;
    renderQueue?: number;
    floatProperties?: {
        [k: string]: number;
    };
    vectorProperties?: {
        [k: string]: number[];
    };
    textureProperties?: {
        [k: string]: number;
    };
    keywordMap?: {
        [k: string]: boolean;
    };
    tagMap?: {
        [k: string]: string;
    };
}
